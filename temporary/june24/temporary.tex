\documentclass{article}
\usepackage{authblk}
\usepackage{blindtext}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\newcommand{\limp}{\Rightarrow}
\newcommand{\WP}[2]{\mathit{WP}(#1,#2)}
\newcommand{\SP}[2]{\mathit{SP}(#1,#2)}
\newcommand{\havoc}{\mathit{havoc}}
\newcommand{\guard}{\mathit{guard}}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92} 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\newtheorem{mydef}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}

\lstset{style=mystyle}
\usepackage[utf8]{inputenc}
\title{Error Localization \& Relevance Analysis \\ }
\author{Matthias Heizmann, Christian Schilling, Numair Mansur}
\affil{University of Freiburg, Germany}
\date{\vspace{-5ex}}
\begin{document}
% ******************************************** BEGIN DOCUMENT **************************************************************************
\section{Relevance}
\subsection{Introduction}
Put an intuvitve idea of our definition of relevance.
\begin{mydef}[Execution]\label{mydef:execution}
Let $\pi$ be an error trace of length $n$. An execution of $\pi$ is a sequence of states $s_0, s_1 ... s_n$ such that $s_i, s_{i+1} \vDash T$, where $T$ is the transition formula of $\pi[i]$.
\end{mydef}
\begin{mydef}[Blocking Execution]\label{mydef:blocked_execution}
An execution of a trace $\pi$ of size $n$ is called a blocking execution, if there exists a sequence of states $s_0,s_1...s_j$ where $i<j \leq n$ such that $s_i, s_{i+1} \vDash T$ where $T$ is the transition formula of $\pi[i]$ and there exists an assume statement in the trace $\pi$ at position $j$ such that $s_j \not \limp guard(\pi[j])$
\end{mydef}

\begin{mydef}[Relevance of an assigning statement]\label{mydef:responsible}
Let $\pi = \langle st_1,....,st_n \rangle$ be an error trace of length $n$ where $st_i$ is an assigning statement at position $i$ that assigns a new value to some variable $x$. The statement $st_i$ is relevant if there exists an execution $s_1,...s_{n+1}$ of $\pi$ and some value $v$ such that every execution of the trace $\langle x:=v; \pi[i+1,n] \rangle$ starting in $s_i$ has a blocking execution.
\end{mydef}

% Checkout the following link for writing an algo in Latex
% https://tex.stackexchange.com/questions/163768/write-pseudo-code-in-latex
\begin{algorithm}
\caption{Relavance of an assigning statement}\label{relevance}
\begin{algorithmic}[1]
\Procedure{Relevance}{}
\State $trace \gets \text{Error trace } \pi \text{ of length } \textit{n}$
\State $relevantStatements \gets \text{[ ]}$
\For{$i = n$ to $1$}
\State $Q \gets \neg wp(false;trace(i+1,n))$
\State $P \gets wp(Q; trace(i)) \cap sp(true; trace(1;i-1))$
\State $relevance \gets checkUnsatCore(P,trace(i),Q)$
\If{$relevance = "unsat"$ and $trace(i)$ in $"unsatCore"$ }
\State $relevantStatements.append(trace(i))$
\EndIf
\EndFor
\Return $relevantStatements$
\EndProcedure
\end{algorithmic}
\end{algorithm}
In the algorithm , we check the relevance of a statement by checking if the triple ($P,\pi[i],\neg Q$) is unsatisfiable and $\pi[i]$ is in the unsatisfiable core. We can do this by checking if $P \not \subseteq WP(Q; havoc(x))$ .

\subsection{Examples}
Consider an error trace $x:=1, y:=2, z:=3, havoc(z), assume(z <=10)$ obtained from the following program:
\begin{lstlisting}
foo()
{
	x := 1;
	y := 2;
	z := 3;
	havoc z;
	assert(z > 10);
}
\end{lstlisting}
In the example above only the havoc statement at line 6 is relevant. One might assume that the assignment statement involving $z$ might also be relevant. But if there exists an execition $\mathcal{E}$ of the trace, there is no assignemnt to $z$ at this point such that we have a blocked execution of the subtrace from this assignment onwards starting with a state taken from the execution $\mathcal{E}$ just before the assignment $z:=3$. \\
Consider another example:
\begin{lstlisting}
foo()
{
  y := 7;
  havoc x;
  assert(x >= 0 && y >= 0);
}
\end{lstlisting}
Only $havoc(x)$ is relevant since there is no assignment to $y$ in line 3 that can make an existing execution of the error trace blocking.\\
\\
(more examples to follow)
\newpage
% ******************************************** NEW PAGE *******************************************************************************
\begin{theorem}[Equivalence of relevance]\label{mydef:relevancytheorem}
Let $\pi = \langle st_1,...,st_i,...,st_n \rangle$ be an error trace of length $n$ and $\pi[i]$ be an assigning statement at position $i$ , which assigns a new value to some variable $x$ . Let $P = \neg WP(False; \pi[i,n]) \cap SP(True; \pi[1,i-1])$ be a set of bireachable states at position $i$ and $Q =  \neg WP(False; \pi[i+1,n])$ be the coreachable states at position $i+1$. The statement $\pi[i]$ is relevant iff:
 $$P \not \subseteq WP(Q,havoc(x))$$
\end{theorem}

\begin{proof}
Let $\mathcal{D}$ be the domain of the variable $x$. \\
"$\Rightarrow$"\\
If $\pi[i]$ is relevant, then\\
$$P \not \subseteq WP(Q;havoc(x))$$
Obviously all the transitions from the states in $WP(Q;havoc(x))$ ends up in $Q$. Relevancy of $\pi[i]$ implies that there is a state in $s \in P$ such that there is a transition from $s$ to $\neg Q$. That would mean:
$$P \not \subseteq WP(Q;havoc(x))$$
"$\Leftarrow$"\\
$\pi[i]$ is relevant, if:
$$P \not \subseteq WP(Q;havoc(x))$$
We know that $WP(Q;havoc(x))$ is the set of states from which all transitions end up in $Q$. The above non implication shows the existence of a state $s$ in $P$ such that $s \not \in WP(Q; havoc(x))$  from which there is a transition to $\neg Q$. This shows the existence of a value $v \in \mathcal{D}$ that we can assign to $x$ such that if we replace $\pi[i]$ with $x:=v$, then every execution is becoming blocking. Also, from our assumption, it is clear that there exits an execution till $P$, since $P$ is not empty.
\end{proof}
\newpage
\section{Comparison with other approaches}
\subsection{Error Invariants approach}
Consider the following example:
\begin{lstlisting}
foo()
{
	x := 7;
	x := 7;
	assert(x > 10);
}
\end{lstlisting}
According to our algorithm, only line number 4 is relevant since only at this location there exits an assignment to x such that the trace from here on is getting blocked. But at line 3, no such assignment exists.\
According to the approach using error invariants, the assignment at line 4 is not relevant since this statement have no effect on the error invariant and the error invariant remains the same (inductive error invariant).\\
Intuitively, it is not so helpful for the user if line 3 is marked relevant. Because even if that line is *fixed*, the program is still ending up in an error state. However, fixing line 4 also fixes the program.\\

\newpage
\section{Previous/Failed approaches:}
\subsection{Replace with havoc and an assume is restrictive}
\subsubsection{Approach}
In this approach, we said that we replace an assignment with a havoc and if some assume in the trace is becoming restrictive then the assignment statement is becoming restrictive. What was the criteria for the havoc again ?
\begin{mydef}[Restrictivness of a statement]
Let $pre$ be a state formula, $\pi$ a trace and $i$ a position such that $\pi[i]$ is an assume statement. We call the assume statement $\pi[i]$ \emph{restricitve} iff :
$$SP(\pi[0,i-1], pre) \not \limp guard(\pi[i])$$
\end{mydef}

\begin{mydef}[Relevance of a statement]
Let $\pi$ be an error trace and $\pi[i]$ be an assignment statement at position $i$ having the form $x:=t$, where $x$ is a variable and $t$ is an expression. Let $\pi'$ be the trace which is obtained by replacing $\pi[i]$ by  $havoc(x)$. Let $\Psi$ be the error precondition of $\pi$. The assignment statement $\pi[i]$ is \emph{relevant} if there exists some assume statement at position $j > i$ in $\pi'$ such that $\pi'[j]$ is restrictive for $\pi'$ and $\Psi$. 
\end{mydef}
\subsubsection{Example where it works}
\begin{lstlisting}
foo()
{
	x := 1;
	y := 2;
	z := 3;
	assert(z > 10);
}
\end{lstlisting}
lines 3 and 4 are not relevant as if we replace them with havoc, no assume in the error trace is becoming restrictive. But if we replace line 5 with $havoc(z)$, then the last assume statement ($assume(z<=10)$)is becoming restrictive. Hence the line with the assignment to $z$ is restrictive.
\subsubsection{Example where it fails}
\begin{lstlisting}
foo()
{
	x := 1;
	y := 2;
	z := 3;
	havoc z;
	assert(z > 10);
}
\end{lstlisting}
In the above example, every statement is now relevant. If we replace any of the assigning statements with $havoc$, the trace is restrictive and not necessarily because of the replacement with havoc but because of the last $havoc(z)$ statement in the program. Hence in this program line 3 and 4 are also relevant.\\
Another example where this approach fails is:
\begin{lstlisting}
procedure main()
{
  y := 42;
  havoc x;
  assume(x >= 0 && y >= 23);
  assert(false);
}
\end{lstlisting}
Here replacing the assignment statement $y:=42$ with $havoc(y)$ have no effect on the restrictivness of an already restrictive error trace. Hence it should not be relevant here. However, clearly this statement have an effect on the rechability of the error.
\subsection{Approach with blocking executions}
\subsubsection{Approach}
We adopted this definition for relevance when we discovered that we should take into account the "amount" of restrictivness of an assume statement instead of just considering if it is getting restrictive or not. 
\begin{mydef}[Execution]\label{mydef:execution_definition}
Let $\pi$ be an error trace of length $n$. An execution of $\pi$ is a sequence of states $s_0, s_1...s_n$ such that $s_i, s_{i+1} \models T$, where $T$ is the transition formula of $\pi[i]$. \\
Let $\epsilon$ represent the set of all possible executions of the error trace.
\end{mydef}

\begin{mydef}[Blocking Execution]\label{mydef:blockingexecution_definition}
An execution of a trace $\pi$ of size $n$ is called a blocking execution if there exists a sequence of states $s_0, s_1...s_j$ where $i<j \leq n$ such that $s_i, s_{i+1} \models T[i]$, where $T[i]$ is the transition formula of $\pi[i]$ and there exits an assume statement in the trace $\pi$ at position $j$ such that $s_{j} \not \limp guard(\pi[j])$.
\end{mydef}

\begin{mydef}[Relevancy of an assignment statement]\label{mydef:relevancy_definition}
Let $\beta$ represent the set of all blocking executions of a trace $\pi$. Let there be an assignment statement of the form $x:=t$ at position $i$. Let $\pi'$ represent the trace that we get after replacing $\pi[i]$ with a havoc statement of the form $havoc(x)$ and let $\beta'$ represent the set of all blocking executions for $\pi'$.\\
We say that the assignment statement $\pi[i]$ is relevant if the trace after the replacement has strictly more blocked executions than the trace before the replacement, i.e if $\beta \subsetneq \beta'$. 
\end{mydef}
\subsubsection{Example where it works}
\begin{lstlisting}
procedure main()
{
  y := 42;
  havoc x;
  assume(x >= 0 && y >= 23);
  assert(false);
}
\end{lstlisting}
This definition now correctly says that $y:=42$ is relevant since changing it to havoc gives us more blocking executions then before.
\subsubsection{Example where it fails}
\begin{lstlisting}
procedure main()
{
  y := 10;
  havoc x;
  assume(x > 0);
}
\end{lstlisting}
In this example, the statement $y:=10$ clearly have nothing to do with error. But changing it to havoc gives us more blocking executions then before and according to this defintion, it is wrongly marked as relevant too. 
\end{document}